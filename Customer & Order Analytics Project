--How many orders were placed in January? 
SELECT COUNT(orderID) AS "Jan orders"
FROM BIT_DB.JanSales
WHERE length(orderID) = 6;

--How many of those orders were for an iPhone?
SELECT COUNT(orderID) AS "Jan iPhone orders"
FROM BIT_DB.JanSales
WHERE Product = 'iPhone'
AND length(orderID) = 6;

--Select the customer account numbers for all the orders that were placed in February.
--It's very important to use DISTINCT as the same customer/account number could have placed multiple orders
SELECT DISTINCT c.acctnum
FROM BIT_DB.customers c
INNER JOIN BIT_DB.FebSales f
ON c.order_id = f.orderID
WHERE length(c.order_id) = 6;

--Which product was the cheapest one sold in January, and what was the price?
--Method #1.0 (Most accurate as it does not limit the number of distinct products with the cheapest price)
--You can use IN instead of <=
SELECT Product, price
FROM BIT_DB.JanSales
WHERE price <= (SELECT MIN(price) FROM BIT_DB.JanSales WHERE length(orderID) = 6)
AND length(orderID) = 6
GROUP BY Product;
--Method #1.1 (Using DISTINCT instead of GROUP BY)
SELECT DISTINCT Product, price
FROM BIT_DB.JanSales
WHERE price IN (SELECT MIN(price) FROM BIT_DB.JanSales WHERE length(orderID) = 6)
AND length(orderID) = 6;
--Method #2 (Least accurate as you are assuming there is only 1 product with the cheapest price)
SELECT DISTINCT Product, price 
FROM BIT_DB.JanSales 
WHERE length(orderID) = 6
ORDER BY price LIMIT 1;
--Method #3 (Also very accurate)
/*In most RDBMS, the software will NOT allow you to select an aggregate function (like MIN(price)) along with a non-aggregate function (like Product)
unless you also have a GROUP BY clause at the end of the query.
This is because without the GROUP BY, the RDBMS doesn't know you're asking for the min(price) of all products, it thinks you're asking for the min(price) of each product.
Since our data doesn't have multiple prices for the same item, this isn't something we'd be interested in seeing. */
SELECT DISTINCT Product, MIN(price) 
FROM BIT_DB.JanSales 
WHERE length(orderID) = 6
GROUP BY product, price
ORDER BY price LIMIT 1;
--Method #3.1 (No need for DISTINCT when using GROUP BY)
SELECT Product, MIN(price) 
FROM BIT_DB.JanSales Jan 
GROUP BY product, price
ORDER BY price LIMIT 1;

/*What is the total revenue for each product sold in January?
(Revenue can be calculated using the quantity of products sold and the price of the products). */
SELECT Product, ROUND((SUM(Quantity)*price)) Revenue
FROM BIT_DB.JanSales
WHERE length(orderID) = 6
GROUP BY Product;

/*Which products were sold in February at 548 Lincoln St, Seattle, WA 98101, 
and how many of each were sold, and what was the total revenue?*/
SELECT Product, SUM(Quantity) Qty, (SUM(Quantity)*price) Revenue
FROM BIT_DB.FebSales
WHERE location = '548 Lincoln St, Seattle, WA 98101'
AND length(orderID) = 6
GROUP BY Product;

/*How many customers ordered more than 2 products at a time in February,
and what was the average amount spent for those customers?*/
SELECT COUNT(distinct c.acctnum), AVG(Quantity*price) Avg
FROM BIT_DB.customers c
INNER JOIN BIT_DB.FebSales f
ON c.order_id = f.orderID
WHERE f.Quantity > 2
AND length(f.orderID) = 6;

--Filtering data by date
SELECT orderdate
FROM BIT_DB.FebSales
WHERE orderdate BETWEEN '02/13/19 00:00' AND '02/18/19 00:00'
ORDER BY orderdate;

SELECT location
FROM BIT_DB.FebSales 
WHERE orderdate = '02/18/19 01:35';

SELECT sum(quantity)
FROM BIT_DB.FebSales 
WHERE orderdate LIKE '02/18/19%';
/*We are telling SQL to only select rows where orderdate starts with 02/18/19, but then anything can come after that, that's what the percentage sign
after the date is for*/
--Therefore, in this query we are telling SQL to select the total quantity of items ordered on 02/18/19

--Other example queries using LIKE
SELECT DISTINCT Product
FROM BIT_DB.FebSales
WHERE Product LIKE '%Batteries%';
--We are selecting any rows from the Product column with distinct values in the Product column containing the word 'Baterries' in its name

SELECT DISTINCT Product, price
FROM BIT_DB.FebSales 
WHERE price LIKE '%.99';
--We are selecting any rows from the Product and price columns with distinct values in the price column containing the characters '.99' at the END of its name

--List all the products sold in Los Angeles in February
SELECT DISTINCT Product
FROM BIT_DB.FebSales 
WHERE location LIKE '%Los Angeles%'
ORDER BY Product;

--List all the products sold in Los Angeles in February, and include how many of each were sold.
SELECT Product, SUM(Quantity)
FROM BIT_DB.FebSales 
WHERE location LIKE '%Los Angeles%'
GROUP BY Product
ORDER BY Product;
--You CANNOT use DISTINCT instead of GROUP BY in this scenario, because you are aggregating data and for that you'll always need to use GROUP BY.
--See for yourself by running the query below.
SELECT DISTINCT Product, SUM(Quantity)
FROM BIT_DB.FebSales 
WHERE location LIKE '%Los Angeles%';

--For a better understanding of DISTINCT, run the query below.
--You will get duplicate products because the location is distinct, the city is the same, but the entire value/text in location will be different.
--The SELECT DISTINCT clause only retrieves distinct values in a specified list (emphasis on list) of columns.
SELECT DISTINCT Product, location
FROM BIT_DB.FebSales 
WHERE location LIKE '%Los Angeles%'
ORDER BY Product;
--You get duplicate products as rows with the same product name but a different location classify as distinct pieces of data
